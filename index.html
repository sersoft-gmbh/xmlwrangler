<!DOCTYPE html>
<html lang="en">
  <head>
    <title>XMLWrangler  Reference</title>
    <link rel="stylesheet" type="text/css" href="css/jazzy.css" />
    <link rel="stylesheet" type="text/css" href="css/highlight.css" />
    <meta charset="utf-8">
    <script src="js/jquery.min.js" defer></script>
    <script src="js/jazzy.js" defer></script>
    
    <script src="js/lunr.min.js" defer></script>
    <script src="js/typeahead.jquery.js" defer></script>
    <script src="js/jazzy.search.js" defer></script>
  </head>
  <body>


    <a title="XMLWrangler  Reference"></a>

    <header class="header">
      <p class="header-col header-col--primary">
        <a class="header-link" href="index.html">
          XMLWrangler 5.3.1 Docs
        </a>
         (92% documented)
      </p>
    
      <div class="header-col--secondary">
        <form role="search" action="search.json">
          <input type="text" placeholder="Search documentation" data-typeahead>
        </form>
      </div>
    
        <p class="header-col header-col--secondary">
          <a class="header-link" href="https://github.com/sersoft-gmbh/xmlwrangler">
            <img class="header-icon" src="img/gh.png" alt="GitHub"/>
            View on GitHub
          </a>
        </p>
    
    </header>

    <p class="breadcrumbs">
      <a class="breadcrumb" href="index.html">XMLWrangler Reference</a>
      <img class="carat" src="img/carat.png" alt=""/>
      XMLWrangler  Reference
    </p>

    <div class="content-wrapper">
      <nav class="navigation">
        <ul class="nav-groups">
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Classes.html">Classes</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/Parser.html">Parser</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/Parser/UnknownError.html">– UnknownError</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/Parser/MissingRootElementError.html">– MissingRootElementError</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Enums.html">Enumerations</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/DocumentEncoding.html">DocumentEncoding</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/EscapableContent.html">EscapableContent</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/EscapableContent/Quotes.html">– Quotes</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/LookupError.html">LookupError</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/XMLContentBuilder.html">XMLContentBuilder</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Extensions.html">Extensions</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Extensions/Dictionary.html">Dictionary</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Extensions/Sequence.html">Sequence</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Extensions/String.html">String</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Protocols.html">Protocols</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/ExpressibleByXMLAttributeContent.html">ExpressibleByXMLAttributeContent</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/ExpressibleByXMLElement.html">ExpressibleByXMLElement</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/XMLAttributeContentConvertible.html">XMLAttributeContentConvertible</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/XMLElementConvertible.html">XMLElementConvertible</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Structs.html">Structures</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/SerializationOptions.html">SerializationOptions</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/XMLElement.html">XMLElement</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/XMLElement/Attributes.html">– Attributes</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/XMLElement/Content.html">– Content</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/XMLElement/Name.html">– Name</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Typealiases.html">Type Aliases</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Typealiases.html#/s:11XMLWrangler32XMLAttributeContentRepresentablea">XMLAttributeContentRepresentable</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Typealiases.html#/s:11XMLWrangler23XMLElementRepresentablea">XMLElementRepresentable</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Typealiases.html#/s:11XMLWrangler9XWElementa">XWElement</a>
              </li>
            </ul>
          </li>
        </ul>
      </nav>
      <article class="main-content">

        <section class="section">
          <div class="section-content top-matter">
            
            <h1 id='xmlwrangler' class='heading'>XMLWrangler</h1>

<p><a href="https://github.com/sersoft-gmbh/xmlwrangler/releases/latest"><img src="https://img.shields.io/github/release/sersoft-gmbh/xmlwrangler.svg?style=flat" alt="GitHub release"></a>
<img src="https://github.com/sersoft-gmbh/xmlwrangler/workflows/Tests/badge.svg" alt="Tests">
<a href="https://www.codacy.com/gh/sersoft-gmbh/xmlwrangler/dashboard?utm_source=github.com&amp;utm_medium=referral&amp;utm_content=sersoft-gmbh/xmlwrangler&amp;utm_campaign=Badge_Grade"><img src="https://app.codacy.com/project/badge/Grade/8932a462fa6d4cd6b2850069c68195c0" alt="Codacy Badge"></a>
<a href="https://codecov.io/gh/sersoft-gmbh/xmlwrangler"><img src="https://codecov.io/gh/sersoft-gmbh/xmlwrangler/branch/master/graph/badge.svg?token=zTgWMfSyCb" alt="codecov"></a>
<a href="https://sersoft-gmbh.github.io/xmlwrangler"><img src="https://raw.githubusercontent.com/sersoft-gmbh/xmlwrangler/gh-pages/badge.svg?sanitize=true" alt="jazzy"></a></p>

<p>Easily deal with XMLs in Swift.</p>
<h2 id='installation' class='heading'>Installation</h2>

<p>Add the following dependency to your <code>Package.swift</code>:</p>
<pre class="highlight swift"><code><span class="o">.</span><span class="nf">package</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="s">"https://github.com/sersoft-gmbh/xmlwrangler.git"</span><span class="p">,</span> <span class="nv">from</span><span class="p">:</span> <span class="s">"5.0.0"</span><span class="p">),</span>
</code></pre>
<h2 id='compatibility' class='heading'>Compatibility</h2>

<ul>
<li>For Swift up to version 5.2, use XMLWrangler version 3.x.y.</li>
<li>For Swift as of version 5.3, use XMLWrangler version 5.x.y.</li>
</ul>
<h2 id='usage' class='heading'>Usage</h2>
<h3 id='xmlelement' class='heading'>XMLElement</h3>

<p>Every element in an XML is represented by the <code><a href="Structs/XMLElement.html">XMLElement</a></code> struct. It has three properties, <code>name</code> which reflects the element&rsquo;s tag name, <code>attributes</code> which contains all attributes of the element and <code>content</code> which describes the content of the element.
The content is an collection whose <code>Element</code> is an enum. The enum has two cases: <code>.string</code> and <code>.element</code>. The order in the collection is the order in which the content has been found. So if an element first contains some text, then contains a child element and finally again some text,  <code>content</code> will contain a <code>.string</code> whose associated <code>StringPart</code> is the first text. Next there would be a <code>.element</code> whose associated <code><a href="Structs/XMLElement.html">XMLElement</a></code> would be the child element. Finally, there would be another <code>.string</code> with the last text.</p>

<p>While you can create an <code><a href="Structs/XMLElement.html">XMLElement</a></code> with a content of <code>[.string(&quot;abc&quot;), .string(&quot;def&quot;), .element(XMLElement(name: &quot;test&quot;))]</code>, and it would also lead to valid XML, it could be cleaned up to <code>[.string(&quot;abcdef&quot;), .element(XMLElement(name: &quot;test&quot;))]</code>. To achieve that, it&rsquo;s recommended to use the various <code>append</code> functions on <code><a href="Structs/XMLElement.html#/s:11XMLWrangler10XMLElementV7contentAC7ContentVvp">XMLElement.content</a></code> or even <code><a href="Structs/XMLElement.html">XMLElement</a></code> directly when you can&rsquo;t assure that the content is cleaned upon creation. If your element was created with an empty content (<code>[]</code>), and you append each of the content elements above, the <code>append</code> functions make sure that they append the &ldquo;def&rdquo; string to the first &ldquo;abc&rdquo; string instead of adding another <code>.string</code> to the content. If for some reason you still end up with a situation where your content has consecutive <code>.string</code> elements, there&rsquo;s a convenience function <code>compress()</code> (or it&rsquo;s non-mutating sibling <code>compressed()</code>), which merges these <code>.string</code> elements into one.</p>

<p>An <code><a href="Structs/XMLElement.html">XMLElement</a></code> can be compared to another element and is considered equal if all three properties (<code>name</code>, <code>attributes</code> and <code>content</code>) are equal. This means that for a big tree, all children of the root element will be compared. So be careful when comparing big trees and fall back to manually comparing <code>name</code> and/or <code>attributes</code> if necessary. <code><a href="Structs/XMLElement.html">XMLElement</a></code> also conforms to <code>Identifiable</code> and uses the <code>name</code> as <code>id</code>.</p>

<p>Both, serializing and parsing XMLs with XMLWrangler relies on <code><a href="Structs/XMLElement.html">XMLElement</a></code>.</p>
<h3 id='parsing-xmls' class='heading'>Parsing XMLs</h3>

<p>Parsing existing XMLs can be done using the <code><a href="Classes/Parser.html">Parser</a></code> class. You can instantiate a parser with either a given <code>Data</code> object or a <code>String</code> containing the XML.</p>

<p>Once you have a parser ready, you can call <code>parse()</code> on it, and it&rsquo;ll try to parse the XML. If that succeeds, it&rsquo;ll return the parsed root object. Otherwise it throws whatever error happend along the way. Errors thrown are the ones created by <code>Foundation.XMLParser</code>.</p>
<pre class="highlight swift"><code><span class="k">do</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">xml</span> <span class="o">=</span> <span class="s">"""
              &lt;?xml version='1.0' encoding='UTF-8'?&gt;
              &lt;root myattr='myvalue'&gt;
                  &lt;child1/&gt;
                  &lt;child2&gt;some text&lt;/child2&gt;
              &lt;/root&gt;
              """</span>
    <span class="k">let</span> <span class="nv">parser</span> <span class="o">=</span> <span class="kt">Parser</span><span class="p">(</span><span class="nv">string</span><span class="p">:</span> <span class="n">xml</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">rootElement</span> <span class="o">=</span> <span class="k">try</span> <span class="n">parser</span><span class="o">.</span><span class="nf">parse</span><span class="p">()</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Something went wrong while parsing: </span><span class="se">\(</span><span class="n">error</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>

<p>In this example, <code>root.name.rawValue</code> would of course be <code>&quot;root&quot;</code>. <code>rootElement.content</code> would contain two <code>.element</code>s. The first would have a associated <code><a href="Structs/XMLElement.html">XMLElement</a></code> with a <code>name</code> of <code>&quot;child1&quot;</code> and an empty <code>content</code>. The <code>name</code> of <code><a href="Structs/XMLElement.html">XMLElement</a></code> of the second <code>.element</code> would be <code>&quot;child2&quot;</code> and its content would contain one <code>.string</code> having <code>&quot;some text&quot;</code> associated. <code>root.attributes</code> would contain the value <code>&quot;myvalue&quot;</code> for the key <code>&quot;myattr&quot;</code>.</p>
<h3 id='serializing-xmlelements' class='heading'>Serializing XMLElements</h3>

<p>Since you can parse XMLs, you can also convert an <code><a href="Structs/XMLElement.html">XMLElement</a></code> to a String. For this, there are two initializers on <code>String</code> added in XMLWrangler.
The first one just converts an <code><a href="Structs/XMLElement.html">XMLElement</a></code> into a <code>String</code>. This happens by creating an opening and ending tag (where the beginning tag contains the <code>attributes</code> if available) and putting the <code>content</code> of the element in between. If <code>content</code> is empty, then no ending tag is created and the opening tag is directly closed with <code>/&gt;</code>. Also, <code>content</code> is compressed (using the aforementioned <code>compress</code> function) before being serialized.</p>
<pre class="highlight swift"><code><span class="k">var</span> <span class="nv">root</span> <span class="o">=</span> <span class="kt">XMLElement</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"root"</span><span class="p">,</span> <span class="nv">attributes</span><span class="p">:</span> <span class="p">[</span><span class="s">"myattr"</span><span class="p">:</span> <span class="s">"myvalue"</span><span class="p">])</span>
<span class="n">root</span><span class="o">.</span><span class="n">content</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="nv">element</span><span class="p">:</span> <span class="s">"child1"</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">content</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="nv">element</span><span class="p">:</span> <span class="kt">XMLElement</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"child2"</span><span class="p">,</span> <span class="nv">content</span><span class="p">:</span> <span class="s">"some text"</span><span class="p">))</span>

<span class="k">let</span> <span class="nv">xml</span> <span class="o">=</span> <span class="kt">String</span><span class="p">(</span><span class="nv">xml</span><span class="p">:</span> <span class="n">root</span><span class="p">)</span> <span class="c1">// -&gt; "&lt;root myattr=\"myvalue\"&gt;&lt;child1/&gt;&lt;child2&gt;some text&lt;/child2&gt;&lt;/root&gt;"</span>
</code></pre>

<p>If the traditional XML header should also be added, there&rsquo;s a second initializer which takes a version and a document encoding as additional parameters, but otherwise follows the same rules:</p>
<pre class="highlight swift"><code><span class="k">var</span> <span class="nv">root</span> <span class="o">=</span> <span class="kt">XMLElement</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"root"</span><span class="p">,</span> <span class="nv">attributes</span><span class="p">:</span> <span class="p">[</span><span class="s">"myattr"</span><span class="p">:</span> <span class="s">"myvalue"</span><span class="p">])</span>
<span class="n">root</span><span class="o">.</span><span class="n">content</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="nv">element</span><span class="p">:</span> <span class="s">"child1"</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">content</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="nv">element</span><span class="p">:</span> <span class="kt">XMLElement</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"child2"</span><span class="p">,</span> <span class="nv">content</span><span class="p">:</span> <span class="s">"some text"</span><span class="p">))</span>

<span class="k">let</span> <span class="nv">xml</span> <span class="o">=</span> <span class="kt">String</span><span class="p">(</span><span class="nv">xmlDocumentRoot</span><span class="p">:</span> <span class="n">root</span><span class="p">,</span> <span class="nv">version</span><span class="p">:</span> <span class="kt">Version</span><span class="p">(</span><span class="nv">major</span><span class="p">:</span> <span class="mi">1</span><span class="p">),</span> <span class="nv">encoding</span><span class="p">:</span> <span class="o">.</span><span class="n">utf8</span><span class="p">)</span>
<span class="c1">// -&gt; "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;root myattr=\"myvalue\"&gt;&lt;child1/&gt;&lt;child2&gt;some text&lt;/child2&gt;&lt;/root&gt;"</span>
</code></pre>

<p>For more information on <code>Version</code> see <a href="https://github.com/sersoft-gmbh/semver">SemVer</a> but note that only <code>major</code> and <code>minor</code> are used for XMLs.
Please note that currently XMLWrangler only supports serializing documents for the following encodings:</p>

<ul>
<li>UTF-8</li>
<li>UTF-16</li>
<li>ASCII</li>
</ul>

<p>Both initializers can take an additional parameter <code>options</code> which contains a set of options to control the serialization behaviour. Currently the following options are possible:</p>

<ul>
<li><code>.pretty</code>: Use pretty formatting. This adds newlines around the tags to make the resulting XML more readable. This is usually not needed for processing XML.</li>
<li><code>.singleQuoteAttributes</code>: When this option is present, then attributes of elements will be enclosed in single quotes (&lsquo;) instead of double quotes (&ldquo;).</li>
</ul>
<h3 id='type-safety' class='heading'>Type safety</h3>

<p>XMLWrangler will always extract all content and attributes as <code>String</code>. This is because XML itself does not differentiate between types like e.g. JSON does.
However, there are many helper functions to safely look up and convert content and attributes of an <code><a href="Structs/XMLElement.html">XMLElement</a></code>:</p>

<ul>
<li>First, there are helpers to extract all child elements with a given name: <code><a href="Structs/XMLElement.html#/s:11XMLWrangler10XMLElementV8elements5namedSayACGAC4NameV_tKF">XMLElement.elements(named:)</a></code></li>
<li>Next, there are helpers to extract an element at a given path: <code><a href="Structs/XMLElement.html#/s:11XMLWrangler10XMLElementV7element2atACx_tKSlRzAC4NameV7ElementRtzlF">XMLElement.element(at:)</a></code></li>
<li>Another helper allows to extract attributes of an element: <code><a href="Structs/XMLElement.html#/s:11XMLWrangler10XMLElementV9attribute3forAC10AttributesV7ContentVAG3KeyV_tKF">XMLElement.attribute(for:)</a></code>.</li>
<li>It is then also possible to convert those attributes (for some types like e.g. <code>RawRepresentable</code> you don&rsquo;t need to pass a <code>converter</code>): <code><a href="Structs/XMLElement.html#/s:11XMLWrangler10XMLElementV18convertedAttribute3for9converterxAC10AttributesV3KeyV_xAH7ContentVKXEtKlF">XMLElement.convertedAttribute(for:converter:)</a></code></li>
<li>Last but not least you can extract the string content of an Element: <code><a href="Structs/XMLElement.html#/s:11XMLWrangler10XMLElementV13stringContentSSyKF">XMLElement.stringContent()</a></code></li>
<li>And of course as you can with attributes, you can also convert string content: <code><a href="Structs/XMLElement.html#/s:11XMLWrangler10XMLElementV22convertedStringContent9converterxxSSKXE_tKlF">XMLElement.convertedStringContent(converter:)</a></code></li>
</ul>

<p>All these methods throw an error (<code><a href="Enums/LookupError.html">LookupError</a></code>) when something went wrong instead of returning optionals. If you prefern an optional, you can always use <code>try?</code>.
For more information also check the header docs which describe these methods a little closer.</p>
<h2 id='possible-features' class='heading'>Possible Features</h2>

<p>While not yet integrated, the following features might provide added value and could make it into XMLWrangler in the future:</p>

<ul>
<li>Indention support for serializing and parsing.</li>
<li>Extracting &quot;KeyPaths&rdquo;: It could be useful to directly extract a path. It would not be necessary to extract every single element then.</li>
</ul>
<h2 id='documentation' class='heading'>Documentation</h2>

<p>The API is documented using header doc. If you prefer to view the documentation as a webpage, there is an <a href="https://sersoft-gmbh.github.io/xmlwrangler">online version</a> available for you.</p>
<h2 id='contributing' class='heading'>Contributing</h2>

<p>If you find a bug / like to see a new feature in XMLWrangler there are a few ways of helping out:</p>

<ul>
<li>If you can fix the bug / implement the feature yourself please do and open a PR.</li>
<li>If you know how to code (which you probably do), please add a (failing) test and open a PR. We&rsquo;ll try to get your test green ASAP.</li>
<li>If you can do neither, then open an issue. While this might be the easiest way, it will likely take the longest for the bug to be fixed / feature to be implemented.</li>
</ul>
<h2 id='license-amp-copyright' class='heading'>License &amp; Copyright</h2>

<p>See <a href="./LICENSE">LICENSE</a> file.</p>

<p>Copyright &copy; 2016-2021 ser.soft GmbH.</p>

          </div>
        </section>


      </article>
    </div>
    <section class="footer">
      <p>&copy; 2022 <a class="link" href="https://sersoft.de" target="_blank" rel="external noopener">ser.soft GmbH</a>. All rights reserved. (Last updated: 2022-03-17)</p>
      <p>Generated by <a class="link" href="https://github.com/realm/jazzy" target="_blank" rel="external noopener">jazzy ♪♫ v0.14.2</a>, a <a class="link" href="https://realm.io" target="_blank" rel="external noopener">Realm</a> project.</p>
    </section>
  </body>
</html>
